#!/usr/bin/env perl
use strict;
use warnings;
use utf8;

use FindBin qw($Bin);
use File::Path qw(rmtree mkpath);
use IO::Handle;
use File::Spec::Functions qw(catfile);
use File::Basename qw(dirname);

# gnu_compat: --opt="..." is allowed.
# no_bundling: single character option is not bundled.
# no_ignore_case: no ignore case on long option.
use Getopt::Long qw(:config gnu_compat no_bundling no_ignore_case);




my @files = qw(
    bin
    .vim
    .vimrc
    .gvimrc
    .vimperator/plugin
    .vimperator/colors
    .vimperatorrc
    .bash_profile
    .bashrc
    .tscreenrc
    .inputrc
    .zshrc
    .zshenv
    .zsh
    .skel
    .module-starter
    .emacs
    .emacs.d
    .w3m/keymap
);
my @removed_files = qw(
    .vim/backup
);
# do not delete these files in home directory if --extract was given
# (if file exists, skip it)
my %dont_overwrite = map { $_ => 1 } qw(
    bin
);



### sub ###

sub usage () {
    die <<EOF;
    Usage: $0 [OPTIONS]

OPTIONS:
    -h, --help                  show this help.
    -u, --username <user>       specify username.
    -c, --commit                update working tree and commit it
    -p, --push                  exec 'git push origin master'
    -x, --extract               extract to current environment.
    --gc                        exec 'git gc' automatically.
EOF
}

# Don't use non-CORE module as possible
use subs qw(say);
*say = sub { print @_, "\n" };

sub install {
    # install $src to $dest as $user.
    my ($src, $dest, $user) = @_;

    unless (-e $src) {
        warn "$src:$!\n";
        return;
    }
    # Delete destination
    # TODO: Use rsync?
    rmtree($dest);

    say("$src -> $dest");
    unless (-d (my $dir = dirname($dest))) {
        mkpath $dir or die "$dir: $!";
    }
    system('cp', '-RL', $src, $dest);

    if ($^O eq 'cygwin') {
        system('chown', '-R', $user, $dest);
    } else {
        system('chown', '-R', "$user:$user", $dest);
    }
}

sub ask {
    my ($msg) = @_;
    STDERR->print("$msg [y/n]:");
    chomp(my $ans = <STDIN>);
    exit unless $ans =~ /^y(es)?$/i;
}



### main ###

# chdir parent directory of this script
chdir $Bin or die "$Bin:$!";

my $username;
my $auto_commit;
my $auto_push;
my $extract;
my $auto_gc;
my $github_user = qx(git config github.user);

if (defined $ENV{USER}) {
    $username = $ENV{USER};
} else {
    die "env 'USER' is not set.\n";
}

my $help;
GetOptions(
    'h|help'       => \$help,
    'u|username=s' => \$username,
    'c|commit'     => \$auto_commit,
    'p|push'       => \$auto_push,
    'x|extract'    => \$extract,
    'gc'           => \$auto_gc,
) or usage;
usage if $help;


if (! $extract && ! defined $github_user) {
    warn "Can't determine GITHUB_USER('git config github.user' is empty).\n";
}

my $home;
if ($username eq 'root') {
    $home = "/root";
} else {
    $home = "/home/$username";
}
unless (-d $home) {
    die "$home:$!"
}

# -x: Extract to current environment
if ($extract) {
    ask("may I replace the dotfiles in '$home'?");
}

for my $file (@files) {
    my ($src, $dest);

    if ($extract) {
        if ($^O eq 'cygwin' && $file eq '.vimperator') {
            $src  = $file;
            $dest = catfile($home, 'vimperator');
        } else {
            $src  = $file;
            $dest = catfile($home, $file);
        }
        if (exists $dont_overwrite{$file}) {
            warn "skip $file...\n";
            next;
        }

        install($src, $dest, $username);

    } else {
        if ($^O eq 'cygwin' && $file eq '.vimperator') {
            $src  = catfile($home, 'vimperator');
            $dest = $file;
        } else {
            $src  = catfile($home, $file);
            $dest = $file;
        }

        install($src, $dest, $username);
    }
}

unless ($extract) {
    rmtree($_) or warn "cannot remove $_: $!" for @removed_files;
}


# -c: Update trees and commit all.
if ($auto_commit) {
    if (length qx(git diff -- .vimrc)) {
        # if .vimrc has changed
        system(qw(vim -c RcbVimrc -c quit));
        sleep 1;
    }

    system(qw(git rm -fr --cached .));
    system(qw(git add .));
    system(qw(git commit));
}
# --gc: 'git gc'
if ($auto_gc) {
    system(qw(git gc));
}
# -p: 'git push origin master'
if ($auto_push) {
    system(qw(git push origin master));
}
