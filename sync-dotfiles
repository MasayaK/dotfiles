#!/usr/bin/env perl
use strict;
use warnings;
use utf8;

use FindBin qw($Bin);
use File::Path qw(rmtree mkpath);
use IO::Handle;
use File::Spec::Functions qw(catfile);
use File::Basename qw(dirname);
use File::Temp qw();

# gnu_compat: --opt="..." is allowed.
# no_bundling: single character option is not bundled.
# no_ignore_case: no ignore case on long option.
use Getopt::Long qw(:config gnu_compat no_bundling no_ignore_case);

my @VIM = qw(vim);
my @VIM_INTERP = qw(vim -u NONE -U NONE --noplugin);
my $VIM_RTP_SCRIPT = './write-runtimepath.vim';



my @files = qw(
    bin
    .vim
    .vimrc
    .gvimrc
    .vimperator/plugin
    .vimperator/colors
    .vimperatorrc
    .bash_profile
    .bashrc
    .screenrc
    .inputrc
    .zshrc
    .zshenv
    .zsh
    .skel
    .module-starter
    .w3m/keymap
    .Xmodmap
    .shrc.common
    .shrc.cygwin
    .shrc.start-screen
    .env.common
    .tmux.conf
    .tmux
    .uim
);
my %cygwin_files = qw(
    .vimperator/plugin  vimperator/plugin
    .vimperator/colors  vimperator/colors
    .vimperatorrc       _vimperatorrc
);
my @removed_files = qw(
    .vim/backup
    .vim/.netrwhist
    .vim/.VimballRecord
    .vim/chalice
    .vim/info
    .vim/record
    .vim/sessions
    .vim/swap
);
my @ignore_files = qw(
    .vim/+vcs
);
# do not delete these files in home directory if --extract was given
# (if file exists, skip it)
my %dont_overwrite = map { $_ => 1 } qw(
    bin
);



### sub ###

sub usage () {
    die <<EOF;
    Usage: $0 [OPTIONS]

OPTIONS:
    -h, --help                  show this help.
    -u, --username <user>       specify username.
    -c, --commit                update working tree and commit it
    -p, --push                  exec 'git push origin master'
    -x, --extract               extract to current environment.
    --gc                        exec 'git gc' automatically.
EOF
}

# Don't use non-CORE module as possible
use subs qw(say);
*say = sub { print @_, "\n" };

sub install {
    # install $src to $dest as $user.
    my ($src, $dest, $user) = @_;

    unless (-e $src) {
        warn "$src:$!\n";
        return;
    }
    # Delete destination
    # TODO: Use rsync?
    rmtree($dest);

    say("$src -> $dest");
    unless (-d (my $dir = dirname($dest))) {
        mkpath $dir or die "$dir: $!";
    }
    system('cp', '-RL', $src, $dest);

    if ($^O eq 'MSWin32' || $^O eq 'msys') {
        # nop
    } elsif ($^O eq 'cygwin') {
        system('chown', '-R', $user, $dest);
    } else {
        system('chown', '-R', "$user:$user", $dest);
    }
}

sub ask {
    my ($msg) = @_;
    STDERR->print("$msg [y/n]:");
    chomp(my $ans = <STDIN>);
    exit unless $ans =~ /^y(es)?$/i;
}

sub slurp_chomp {
    my ($path) = @_;

    open my $FH, '<', $path or die $!;
    my @lines = <$FH>;
    close $FH;

    map { chomp; $_ } @lines;
}

sub get_git_files_from_runtimepath {
    my $tempname = do {
        my $fh = File::Temp->new(UNLINK => 0) or die $!;
        $fh->filename;
    };
    system(@VIM, '-S', $VIM_RTP_SCRIPT, $tempname);

    my @ret;
    for my $rtp (slurp_chomp $tempname) {
        $rtp = readlink $rtp while -l $rtp;

        my $repo = eval { Git->repository($rtp) };
        next if $@;

        push @ret, map {
            # [fullpath, relpath]
            [catfile($repo->wc_path, $_), $_]
        } $repo->command('ls-files')
            or warn "Empty repository?: $!"
    }
    @ret;
}

sub get_home {
    my ($username) = @_;
    my $home;

    if (defined $ENV{HOME}) {
        $home = $ENV{HOME};
    }
    elsif ($^O eq 'MSWin32') {
        if (defined $ENV{MSYSCON}) { # TODO Detect cygwin
            $home = "/home/$username";
        } else {
            die "where is my home?";
        }
    }
    else {
        if ($username eq 'root') {
            $home = "/root";
        } else {
            $home = "/home/$username";
        }
    }

    unless (-d $home) {
        die "$home:$!"
    }

    $home;
}



### main ###

# chdir parent directory of this script
chdir $Bin or die "$Bin:$!";

my $home;
my $username;
my $auto_commit;
my $auto_push;
my $extract;
my $auto_gc;
my $upload_to_vimrcbox;
my $get_git_files_from_runtimepath;
my $github_user = qx(git config github.user);

if (defined $ENV{USER} || defined $ENV{USERNAME}) {
    $username = $ENV{USER} || $ENV{USERNAME};
} else {
    die "env 'USER' is not set.\n";
}

my $help;
GetOptions(
    'help'
        => \$help,
    'h|home=s'
        => \$home,
    'u|username=s'
        => \$username,
    'c|commit'
        => \$auto_commit,
    'p|push'
        => \$auto_push,
    'x|extract'
        => \$extract,
    'gc'
        => \$auto_gc,
    'v|vimrcbox'
        => \$upload_to_vimrcbox,
    'g|get-git-files'
        => \$get_git_files_from_runtimepath,
) or usage;
usage if $help;


if (! $extract && ! defined $github_user) {
    warn "Can't determine GITHUB_USER('git config github.user' is empty).\n";
}

$home ||= get_home $username;

# -x: Extract to current environment
if ($extract) {
    ask("may I replace the dotfiles in '$home'?");
}

for my $file (@files) {
    my ($src, $dest);

    if ($extract) {
        if ($^O eq 'cygwin' && exists $cygwin_files{$file}) {
            $src  = $file;
            $dest = catfile($home, $cygwin_files{$file});
        } else {
            $src  = $file;
            $dest = catfile($home, $file);
        }
        if (exists $dont_overwrite{$file}) {
            warn "skip $file...\n";
            next;
        }

        install($src, $dest, $username);

    } else {
        if ($^O eq 'cygwin' && exists $cygwin_files{$file}) {
            $src  = catfile($home, $cygwin_files{$file});
            $dest = $file;
        } else {
            $src  = catfile($home, $file);
            $dest = $file;
        }

        install($src, $dest, $username);
    }
}

if ($extract) {
    mkdir "$ENV{HOME}/.vim/backup";
}
else {
    for my $f (@removed_files) {
        if (-e $f) {
            rmtree($f) or warn "cannot remove $_: $!";
        }
    }
}


# -c: Update trees and commit all.
if ($auto_commit) {
    system(qw(git rm -fr --cached .));
    system(qw(git add .));
    system(qw(git commit));
}
# --gc: 'git gc'
if ($auto_gc) {
    system(qw(git gc));
}
# -p: 'git push origin master'
if ($auto_push) {
    system(qw(git push origin master));
}
# -v, --vimrcbox: upload to vimrcbox.
if ($upload_to_vimrcbox) {
    system(@VIM_INTERP, q(-c), q(source vimrcbox.vim | RcbVimrc), qw(-c quit));
}
# -g, --get-git-files: Get git cached files using by git-ls-files.
if ($get_git_files_from_runtimepath) {
    require Git;
    my @files = get_git_files_from_runtimepath();
    for my $f (@files) {
        my ($fullpath, $relpath) = @$f;
        install($fullpath, $relpath, $username);
    }
}
