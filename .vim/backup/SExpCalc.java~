package calc;
import java.io.*;
import java.util.*;




public class SExpCalc {

    private String  sexp;
    private String  ignoreChars;
    private SimpleTokenizer tokenizer = new SimpleTokenizer();
    private boolean initializedTokenizer = false;

    private static final int SCM_NUMBER = 1;
    private static final int SCM_FUNC = 2;
    private static final int SCM_LPAREN = 3;
    private static final int SCM_RPAREN = 4;


    public SExpCalc() {
        clear();
    }

    public void clear() {
        this.sexp = null;
        this.ignoreChars = " \t\r\n";
        this.tokenizer.clear();
    }

    // tokenizerにSchemeのトークンを覚えさせる
    // NOTE: 呼ぶのはthis.sexpがnullでない時のみ
    private void init() {
        tokenizer.setIgnoreChars(ignoreChars);
        // this.ignoreChars = null;    // DEBUG!!!
        tokenizer.addToken(SCM_NUMBER, '0', '9');
        // tokenizer.addToken(SCM_NUMBER, '-');
        tokenizer.addToken(SCM_NUMBER, '.');
        tokenizer.addToken(SCM_FUNC, '+');
        tokenizer.addToken(SCM_FUNC, '-');
        tokenizer.addToken(SCM_FUNC, '*');
        tokenizer.addToken(SCM_FUNC, '/');
        tokenizer.addToken(SCM_LPAREN, '(');
        tokenizer.addToken(SCM_RPAREN, ')');
        this.initializedTokenizer = true;
    }

    public void initArgs(String[] args) {
        for (String a : args) {
            if (a.equals("--debug")) {
                this.debug = true;
                this.tokenizer.debug = true;
            } else if (a.equals("--no-debug")) {
                this.debug = false;
                this.tokenizer.debug = false;
            }
        }
    }

    public void eval(String sexp) throws SyntaxError {
        clear();
        setSExp(sexp);
        try {
            run(false);    // this.sexpをnullにしないため
        } catch (NoSExpStringException e) {
            System.err.println("this block will be never reached!");
            e.printStackTrace();
        }
    }

    // EOFまで、複数のS式をそれぞれ読んで結果を表示する
    public void run() throws NoSExpStringException, SyntaxError {
        run(true);
    }
    public void run(boolean clearStat) throws NoSExpStringException, SyntaxError {
        if (this.sexp == null)
            throw new NoSExpStringException("文字がセットされていません");
        if (! this.initializedTokenizer)
            init();
        if (clearStat)
            clear();

        while (true) {
            Token result = parse();
            if (result == null) {
                break;
            } else if (result.id == SCM_NUMBER) {
                System.out.println("計算結果:" + result.sval);
            } else {
                System.out.println("アトムのID:" + result.id + ", 結果:" + result.sval);
            }
        }
    }

    // 1つのS式の結果を返す
    private Token parse() throws SyntaxError {
        Token first = null;
        try {
            first = tokenizer.nextToken();
        } catch (NullPointerException e) {
            ;
        }
        if (first == null || first.id == SCM_RPAREN)    return null;

        dprint("parse(): first.id " + first.id + ", first.sval " + first.sval);

        if (first.id == SCM_LPAREN) {
            Token func = parse();

            ArrayList<Token> args = new ArrayList<Token>();
            while (true) {
                Token token = parse();
                if (token == null) {
                    break;
                }
                args.add(token);
            }
            return (Token)dispatchFunction(func, args);
        } else {
            return first;
        }
    }


    public void setSExp(String s) {
        dprint("set buffer string [" + s + "]");
        this.sexp = new String(s);
        this.tokenizer.setBuffer(this.sexp);
    }

    // 関数をコールする
    // TODO: リフレクション機能使う
    // (具体的にはHashMapを使ってSchemeの関数とそれに対するJavaの関数の表を作り実行する)
    private Object dispatchFunction(Token func, ArrayList<Token> args) throws SyntaxError {
        float result = 0;
        if (func == null || func.id != SCM_FUNC) {
            throw new UnknownFunctionException(func.id + "");
        }

        if (func.sval.equals("+")) {
            for (Token n : args) {
                result += Float.parseFloat(n.sval);
            }
        } else if (func.sval.equals("-")) {
            for (Token n : args) {
                result -= Float.parseFloat(n.sval);
            }
        } else if (func.sval.equals("*")) {
            result = 1;
            for (Token n : args) {
                result *= Float.parseFloat(n.sval);
            }
        } else if (func.sval.equals("/")) {
            result = 1;
            for (Token n : args) {
                result /= Float.parseFloat(n.sval);
            }
        } else {
            System.err.println("unknown function " + func.sval + " found");
            throw new UnknownFunctionException(func.sval);
        }

        return new Token(result, SCM_NUMBER);
    }

    public boolean debug = true;
    private void dprint(String msg) {
        if (debug)
            System.err.println(msg);
    }
}

