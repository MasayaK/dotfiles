use Test::More skip_all => "not implemented Text::Tokenizer::Class::Token::Group yet...";

use Text::Tokenizer::Class;
my $parser = Text::Tokenizer::Class->new(parse_type => 'group');

is($parser->parse_type, 'group', 'parse type is group');
ok(! $parser->has_string, "parser hasn't have data yet");

my %groups = (
    'scm_comment' => ';',
    'scm_lparen'  => '(',
    'scm_rparen'  => ')',
    'scm_symbol'  => "'",
    'scm_keyword' => ':',
    'scm_sharp'   => '#',
    'scm_string'  => '"',
    'scm_word'    => qr/[\w.!?\$%&<>+\-*\/=^~|]/,
    # can't add "default" as group.
    # 'default' => 1,
);
for (keys %groups) {
    $parser->add_pattern($_ => $groups{$_});
}
$parser->ignore_chars(qr/\s/);
# $parser->list_ignore_char
# $parser->list_pattern;

$parser->set_string_from_fh(\*DATA);
ok($parser->has_string, 'now parser has string');


my $i = 0;
until ($parser->eof_string) {
    if ($i == 0) {
        ok(1, 'this block is reached');
        $reached = 1;
    }
    # •Ô‚·Œ‹‰Ê‚Íparse_type‚É‚æ‚Á‚Äˆá‚¤
    # my @groups = $parser->parse(dont_step => 1);
    # $parser->step;
    $i++;
    for my $g ($parser->parse) {
        if ($g eq 'scm_comment') {
            $parser->step('until' => "\n");
        }
        warn "### $i: read $groups{$g} ###\n";
    }
}



__END__

(print (+ 1 1))    # => 2
(print (+ (* 3 3) (* 4 4)))    # => 25
