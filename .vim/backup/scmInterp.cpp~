
#include "scmInterp.h"


int
// repl(std::string msg, std::istream& in, void (*print)(std::string msg)) {
repl(std::istream& in) {
    char ch;
    std::string sexp;

    // while (in.get(ch)) {
    //     if (in.fail()) {
    //         throw FileReadException();
    //     }
    //     sexp.append(1, ch);
    // }
    // in.close();

    while (! in.eof()) {
        getline(in, sexp);
        if (in.fail()) {
            return EXIT_FAILURE;
        }

        try {
            setSexp(sexp);
            for (int i = 0; ! eof(); i++) {
                ScmAtom *result = parse();
                std::cout
                    << "result:"
                    << formatForDisplay(result)
                    << std::endl;
            }
        } catch () {
        }
    }

    return EXIT_SUCCESS;
}

ScmAtom*
ScmInterp::parse() {
    ScmAtom token = this->tokenizer.nextToken();
    dprint("# token[" + token.sval + "], id[" + string(token.id) + "]");

    if (token.id == SCM_RPAREN) {
        throw SyntaxErrorException("extra close parenthesis");
    } else if (token.id == SCM_SQUOTE || token.id == SCM_COLON) {
    } else if (token.id == SCM_SYMBOL) {
        return new ScmAtom(token);
    } else if (token.id == SCM_LPAREN) {
    }
}

