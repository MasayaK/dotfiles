use Test::More qw(no_plan);

use Text::Tokenizer::Class;
use Scalar::Util qw(looks_like_number);
use Perl6::Say;


my $parser = Text::Tokenizer::Class->new(parse_type => 'handler');
$parser->ignored_chars(qr/\s/);

$parser->add_pattern(
    qr/[+\-*\/]/ => sub { shift->step }
);
$parser->add_pattern(
    sub { looks_like_number($_) } => sub { shift->step }
);
$parser->add_pattern(    # for set!
    qr/[\w!]/ => sub { shift->step }
);
$parser->add_pattern(
    '(' => sub {
        my $self = shift;
        my $proc = $self->parse(post_stop_if_found => 1);
        if ($proc eq 'set!') {
            my $var_name = $self->step(qr/\w/);
            my $n = $self->step("\n");
            if ($var_name ne "" && $n ne "") {
                $self->{_var}->{$var_name} = $n;
            }
        } else {
            my @nums;
            while (1) {
                my $n = $self->parse(post_stop_if_found => 1);
                last    unless defined $n;
                push @nums, $n;
            }
            eval join $proc, @nums;
        }
    }
);
$parser->add_pattern(
    ')' => sub { undef }
);

$parser->string("(+ 1 1)");
is($parser->parse(), 2, '(+ 1 1) is 2');
$parser->string("(+ (* 3 3) (* 4 4))");
is($parser->parse(), 25, '(+ (* 3 3) (* 4 4)) is 25');
$parser->string("(/ (/ (+ 100) 4) 5)");
is($parser->parse(), 5, '(/ (/ (+ 100) 4) 5) is 5');


